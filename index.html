<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R Quantile Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" xintegrity="sha384-GvrSgR2D6g3X7jWzJ/76v1r2C2X4zC6hGq5aF3Vb7l+J2g/78+xKz1mF4Kz6t8Hq7F" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" xintegrity="sha384-x4B3s48TzF4b7rR/7d6/22n6Kz8+3y6/nF5tP4q2U6jW" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" xintegrity="sha3384-h0/nC4F3Jg7rF4Kz6t8Hq7F" crossorigin="anonymous"></script>
    
    <style>
        /* Ensure KaTeX math symbols inherit the parent text color */
        .symbol-key .katex {
            color: inherit !important; 
        }

        /* Custom font for data output */
        .font-mono-data {
            font-family: 'Consolas', 'Courier New', monospace;
        }
        
        /* Base styles for all buttons in the group */
        .type-btn {
            background-color: #f7f7f7; 
            color: #4b5563; 
            border: 1px solid #d1d5db; 
            outline: none;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
            user-select: none; /* Prevent text selection during drag */
        }
        .type-btn:not(.active):hover {
            background-color: #e5e7eb; 
        }
        /* Active (ON) state */
        .type-btn.active {
            background-color: #3b82f6; 
            color: white;
            border-color: #3b82f6;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        
        #type-selector-group {
            border: none; 
        }
        .formula-box {
            background-color: #e0f2fe; 
            color: #0d3b66; 
            padding: 8px;
            border-radius: 4px;
            margin-top: 6px;
            font-size: 0.85rem;
            overflow-x: auto;
        }

        /* Styles for clickable card (entire area) */
        .result-card {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .result-card:hover {
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2); /* Stronger shadow on hover */
            transform: translateY(-2px); /* Slight lift */
            border-color: #3b82f6; /* Blue border on hover */
            background-color: #f7f9ff; /* Very light background change */
        }

        /* --- Animation for Border Flash (Green Light Effect) --- */
        .flash-border-green {
            animation: flash-green 1.0s ease-out; /* Slower duration */
        }

        @keyframes flash-green {
            0% { 
                /* Starting shadow (softer green-500) */
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.3); 
                border-color: #d1d5db; /* Original border color */
            }
            50% { 
                /* Peak flash: smaller spread, lower opacity (less bright) */
                box-shadow: 0 0 12px 4px rgba(16, 185, 129, 0.6); 
                border-color: #10b981; /* Green-500 border at peak */
            }
            100% { 
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); /* Shadow fade out */
                border-color: #d1d5db; /* Back to original border color */
            }
        }
        
        /* New styles for Copy Buttons FADE animation */
        .copy-buttons-fade-enter {
            opacity: 0;
            max-height: 0;
        }
        .copy-buttons-fade-enter-active {
            opacity: 1;
            max-height: 96px; /* Enough height to show the content */
            transition: opacity 300ms ease-out, max-height 300ms ease-out;
        }
        .copy-buttons-fade-leave {
            opacity: 1;
            max-height: 96px;
        }
        .copy-buttons-fade-leave-active {
            opacity: 0;
            max-height: 0;
            transition: opacity 300ms ease-in, max-height 300ms ease-in;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8">

    <div class="max-w-5xl mx-auto bg-white shadow-2xl rounded-xl p-6 md:p-10">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-2 border-b-4 border-blue-500 pb-3">R Quantile Calculator (Simulation)</h1>
        
        <div class="flex flex-wrap gap-3 mb-6">
            <a href="https://hwan289.github.io/CIMI-Ranking-Calculator/" target="_blank" class="px-4 py-2 bg-blue-500 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-blue-600 transition duration-200">
                CIMI Ranking Calculator
            </a>
            <a href="https://hwan289.github.io/log-odds-odds-probability-converter/" target="_blank" class="px-4 py-2 bg-blue-500 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-blue-600 transition duration-200">
                Log-Odds Converter
            </a>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8 bg-blue-50 p-6 rounded-lg border border-blue-200">
            <div class="md:col-span-2">
                <label for="data-input" class="block text-base font-semibold text-gray-700 mb-2">Enter Data (Comma- or Space-separated numbers):</label>
                <textarea id="data-input" rows="3" class="w-full border-gray-300 rounded-lg shadow-inner p-3 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm">2, 5, 8, 12, 15, 18, 22, 25, 28, 30</textarea>
                <p class="text-xs text-gray-500 mt-2">
                    <span class="font-bold">$\text{\textbf{Note}}$:</span> Non-numeric values are ignored. Calculations are performed on the sorted, cleaned data set.
                </p>
            </div>
            <div class="md:col-span-1">
                <label class="block text-base font-semibold text-gray-700 mb-2">Select Quantile Types (1-9):</label>
                <div id="type-selector-group" class="grid grid-cols-5 gap-1 mt-2">
                    <button data-type="1" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 1">1</button>
                    <button data-type="2" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 2">2</button>
                    <button data-type="3" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 3">3</button>
                    <button data-type="4" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 4">4</button>
                    <button data-type="5" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 5">5</button>
                    <button data-type="6" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 6 (R Default)">6</button>
                    <button data-type="7" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 7 (S Default)">7</button>
                    <button data-type="8" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 8">8</button>
                    <button data-type="9" class="type-btn p-2 text-sm font-semibold rounded active" title="Type 9 (SPSS/SAS Default)">9</button>
                </div>
                <p class="text-xs text-gray-700 mt-2 text-center">
                    <span class="font-bold">Drag to select/deselect!</span> Clicking and dragging toggles state on hover.
                </p>
            </div>
        </div>

        <div class="flex justify-center space-x-4 mb-8">
            <button id="run-button" onclick="runRCode()" class="px-8 py-3 bg-blue-600 text-white text-lg font-bold rounded-full shadow-lg hover:bg-blue-700 transition duration-200 ease-in-out disabled:opacity-50">
                Run Simulation
            </button>
            <button id="clear-data-button" onclick="clearDataInput()" class="px-8 py-3 bg-red-600 text-white text-lg font-bold rounded-full shadow-lg hover:bg-red-700 transition duration-200 ease-in-out">
                Clear Data
            </button>
        </div>

        <div>
            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4 border-b pb-2">
                <h2 class="text-xl font-bold text-gray-800 mb-3 sm:mb-0">Quantile Calculation Results</h2>
                
                <div class="flex flex-col md:flex-row md:items-center space-y-3 md:space-y-0 md:space-x-4">
                    
                    <div class="flex items-center space-x-2">
                        <label for="show-outliers-toggle" class="text-sm font-semibold text-gray-700 whitespace-nowrap">Show Outlier Analysis:</label>
                        <button id="show-outliers-toggle" 
                                class="w-12 h-6 flex items-center rounded-full p-1 bg-gray-300 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                                role="switch" aria-checked="false" onclick="toggleOutlierAnalysis()">
                            <span class="w-4 h-4 bg-white rounded-full shadow-md transform transition-transform duration-300" 
                                  id="outlier-toggle-circle"></span>
                        </button>
                    </div>

                    <div id="copy-buttons-container" 
                         class="copy-buttons-fade-leave transition-all duration-300 ease-in-out 
                                flex flex-col sm:flex-row sm:items-center space-y-2 sm:space-y-0 sm:space-x-2">
                        
                        <a href="https://www.programiz.com/r/online-compiler/" 
                           target="_blank" 
                           rel="noopener noreferrer" 
                           id="copy-r-compiler-link" 
                           onclick="copyRCompilerLink(); return false;" 
                           class="px-4 py-2 bg-blue-600 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-200 text-center">
                            Online R Compiler (Right Click to Open)
                        </a>
                        <button id="copy-r-code-button" onclick="copyRCode()" class="px-4 py-2 bg-purple-600 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-purple-700 transition duration-200 disabled:opacity-50">
                            Copy R Code for Verification
                        </button>
                        <button id="copy-all-button" onclick="copyAllResults()" class="px-4 py-2 bg-green-600 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-200 disabled:opacity-50">
                            Copy ALL Results for Excel
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="results-container" class="space-y-3 min-h-[100px] bg-gray-50 p-4 rounded-lg border border-gray-200">
                <p class="text-gray-500 text-center py-4">Results will appear here after running the simulation.</p>
            </div>
        </div>
        
        <div class="mt-12 pt-6 border-t border-gray-300">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Definitions and Formulas of R Quantile Types (1-9)</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8 text-sm p-4 bg-gray-50 rounded-lg">
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$\text{Q}_p$</span>: <span class="text-gray-700">The calculated Quantile Value.</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$n$</span>: <span class="text-gray-700">The number of observations (data points).</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$p$</span>: <span class="text-gray-700">The probability ($0 \le p \le 1$), e.g., $0.25$ for the first quartile.</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$x(i)$</span>: <span class="text-gray-700">The $i$-th smallest ordered observation (order statistic).</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$j$</span>: <span class="text-gray-700">The calculated index (real number).</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$i$</span>: <span class="text-gray-700">The integer part of $j$, used for selection: $i = \lfloor j \rfloor$.</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$g$</span>: <span class="text-gray-700">The fractional part of $j$, used for weighting: $g = j - i$.</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$m$</span>: <span class="text-gray-700">The offset constant.</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$\mathbb{Z}$</span>: <span class="text-gray-700">The set of all Integers ($\dots, -2, -1, 0, 1, 2, \dots$).</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$\in$</span>: <span class="text-gray-700">Symbol for "is an element of" or "belongs to".</span>
                </div>
                <div class="border-b pb-2 symbol-key">
                    <span class="text-orange-600 font-bold text-lg">$\notin$</span>: <span class="text-gray-700">Symbol for "is NOT an element of" or "does NOT belong to".</span>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 text-sm text-gray-700" id="formula-list">
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 1</p>
                    <p>The inverse of the empirical distribution function.</p>
                    <div class="formula-box">
                        $$j = np$$
                        $$Q_p = x(\lceil j \rceil)$$
                    </div>
                </div>
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 2</p>
                    <p>Similar to Type 1, but averages at discontinuities.</p>
                    <div class="formula-box">
                        $$j = np$$
                        $$\text{If } j \in \mathbb{Z}: Q_p = \frac{x(j) + x(j+1)}{2}$$
                        $$\text{If } j \notin \mathbb{Z}: Q_p = x(\lceil j \rceil)$$
                    </div>
                </div>
                
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 3</p>
                    <p>SAS definition: nearest even order statistic.</p>
                    <div class="formula-box">
                        $$j = \lfloor np - 1/2 \rfloor$$
                        $$\text{If } (np-1/2) \in \mathbb{Z} \text{ and } j \text{ is even, } Q_p = x(j);$$ 
                        $$\text{ else } Q_p = x(j+1)$$
                    </div>
                </div>
            
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 4</p>
                    <p>Linear interpolation of the empirical cumulative distribution function (ECDF).</p>
                    <div class="formula-box">
                        $$j = np$$
                        $$Q_p = (1 - g) x(i) + g x(i+1)$$
                    </div>
                </div>
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 5 (Default in Stata: $m=1/2$)</p>
                    <p>A piecewise linear function where the knots are the values midway between the steps.</p>
                    <div class="formula-box">
                        $$j = np + 1/2$$
                        $$Q_p = (1 - g) x(i) + g x(i+1)$$
                    </div>
                </div>
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 6 (Default in Minitab: $m=0$)</p>
                    <p>Index $j = (n+1)p$.</p>
                    <div class="formula-box">
                        $$j = (n+1)p$$
                        $$Q_p = (1 - g) x(i) + g x(i+1)$$
                    </div>
                </div>
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 7 (Default in Excel and R: $m=1$)</p>
                    <p>Piecewise linear function.</p>
                    <div class="formula-box">
                        $$j = (n-1)p + 1$$
                        $$Q_p = (1 - g) x(i) + g x(i+1)$$
                    </div>
                </div>
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 8 ($m=1/3$)</p>
                    <p>Approximation of expected order statistic (Normal). The resulting quantile estimates are approximately median-unbiased regardless of the distribution of x.</p>
                    <div class="formula-box">
                        $$j = \left(n + 1/3\right) p + 1/3$$
                        $$Q_p = (1 - g) x(i) + g x(i+1)$$
                    </div>
                </div>
                
                <div class="p-3 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="font-bold text-blue-700 mb-1">Type 9 ($m=3/8$)</p>
                    <p>Approximation of expected order statistic (Uniform).</p>
                    <div class="formula-box">
                        $$j = \left(n + \frac{1}{4}\right) p + \frac{3}{8}$$
                        $$Q_p = (1 - g) x(i) + g x(i+1)$$
                    </div>
                </div>
            </div>
        </div>
        
        <div class="mt-12 pt-6 border-t border-gray-300">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Reference</h2>
            <div class="pl-4">
                <a href="https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/quantile" 
                   target="_blank" 
                   rel="noopener noreferrer" 
                   id="copy-r-documentation-link"
                   onclick="copyRDocumentationLink(); return false;"
                   title="Left-click to copy citation, Right-click to open link." 
                   style="cursor: pointer; display: block;" 
                   class="text-gray-700 hover:text-gray-900">
                    R Documentation. (2020). <span class="italic">R: Quantile calculation.</span> (R package stats version 3.6.2). 
                    <span class="text-blue-600 hover:text-blue-700 underline font-medium break-all">https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/quantile</span>
                </a>
            </div>
        </div>
        
        <div class="text-xs text-gray-500 mt-4 text-right">
            Created: October 29, 2025
        </div>
    </div>
    
    <div id="copy-toast" class="fixed bottom-5 right-5 bg-green-600 text-white px-6 py-3 rounded-lg shadow-xl opacity-0 transition-opacity duration-300 ease-out pointer-events-none z-50 font-semibold">
        Copied to Clipboard!
    </div>

    <script>
        // Global storage for results to enable the "Copy All" and "Copy Single" functions
        let simulationResults = [];
        let rawDataArray = []; // Store the cleaned, sorted data array for R code generation
        let initialDataInputCount = 0; // NEW: Store initial number of inputs
        let isDragging = false; // Global state for drag interaction
        let showOutliers = false; // Global state for the outlier toggle
        let debounceTimer; // GLOBAL: Debounce timer for the toggle switch
        let cardTimers = []; // GLOBAL: Array to store all setTimeout IDs for card creation (FIX: Disorganization issue)

        /**
         * Standard debounce utility function.
         */
        function debounce(func, timeout = 400){
            return (...args) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => { func.apply(this, args); }, timeout);
            };
        }
        
        /**
         * Calculates the quantile Qp for a given probability p using one of the 9 R quantile types.
         * The input data must be sorted.
         * @param {number[]} data - The sorted array of numerical data (x(1), x(2), ..., x(n)).
         * @param {number} p - The probability (0 <= p <= 1).
         * @param {number} type - The R quantile type (1 to 9).
         * @returns {number} The calculated quantile value.
         */
        function calculateQuantile(data, p, type) {
            const n = data.length;
            
            // 1. Edge Cases for 0% and 100%
            if (p <= 0) return data[0];
            if (p >= 1) return data[n - 1];

            let j, i, g; // Index, integer part, and fractional part

            // Calculate j based on the R quantile type formula
            switch (type) {
                // --- Discrete Index Types ---
                case 1:
                    // R-1: Inverse of ECDF. Qp = x(ceil(n * p))
                    j = n * p;
                    i = Math.ceil(j);
                    // i is 1-based index. Clamp i between 1 and n.
                    i = Math.max(1, Math.min(n, i));
                    return data[i - 1]; // 0-based index is i-1

                case 2:
                    // R-2: ECDF with midpoints.
                    j = n * p;
                    i = Math.floor(j);
                    
                    // If j is an integer, average x(j) and x(j+1)
                    if (j === i) { 
                        // i is 1-based index. Clamp i between 1 and n-1 for averaging.
                        i = Math.max(1, Math.min(n - 1, i));
                        return (data[i - 1] + data[i]) / 2;
                    } else { // j is not an integer, Qp = x(ceil(j))
                        i = Math.ceil(j);
                        i = Math.max(1, Math.min(n, i));
                        return data[i - 1];
                    }
                
                // New Type 3 logic (based on the screenshot's specific definition for m=-1/2 and gamma rule)
                case 3:
                    const m = -0.5;
                    const np_plus_m = n * p + m;
                    
                    // The index j is the integer part (1-based index)
                    // Note: The screenshot uses 'j' for the floor, which is 'i' in the continuous formulas (Types 4-9)
                    // To match the previous answer's derivation (which used j as the floor index), 
                    // we use i for floor index and g for fractional part.
                    i = Math.floor(np_plus_m); // The index 'j' from the previous response
                    g = np_plus_m - i;         // The fractional part 'g' from the previous response
                    
                    // Clamp i to be a valid 1-based index (min 1, max n)
                    i = Math.max(1, Math.min(n, i));
                
                    let gamma; 
                    
                    // Type 3 Gamma Rule: gamma = 0 if g = 0 AND j (which is 'i' here) is even, and 1 otherwise.
                    if (g === 0 && i % 2 === 0) { // i % 2 === 0 checks if j (i) is even
                        gamma = 0;
                    } else {
                        gamma = 1;
                    }
                    
                    // Qp = (1 - gamma) * x(i) + gamma * x(i+1)
                    
                    // 0-based index for x(i) is i-1
                    const idx_i = Math.max(0, Math.min(n - 1, i - 1));
                    // 0-based index for x(i+1) is i
                    const idx_i_plus_1 = Math.max(0, Math.min(n - 1, i));
                
                    const x_i = data[idx_i];
                    const x_i_plus_1 = data[idx_i_plus_1];
                    
                    return (1 - gamma) * x_i + gamma * x_i_plus_1;
                    
                // --- Linear Interpolation Types (Continuous) ---
                // Qp = (1 - g) * x(i) + g * x(i+1) where j = (n-2m)p + m
                case 4: j = n * p; break; // m=0
                case 5: j = n * p + 0.5; break; // m=0.5. 
                case 6: j = (n + 1) * p; break; // m=0 (Simplified form)
                case 7: j = (n - 1) * p + 1; break; // m=1 (Simplified form) - R DEFAULT
                case 8: j = (n + 1/3) * p + 1/3; break; // m=1/3 (Simplified form)
                
                case 9: 
                    // Type 9 index calculation for m=3/8
                    j = (n + 0.25) * p + 0.375; 
                    break; // SAS/SPSS DEFAULT
                
                default: return NaN;
            }

            // Common Interpolation Logic for Types 4-9
            i = Math.floor(j); // 1-based index for x(i)
            g = j - i;         // Fractional part

            // If i is an integer (g=0), the value is x(i)
            if (g === 0) {
                // R uses the actual value at index i (x(i))
                i = Math.max(1, Math.min(n, i)); // Clamp
                return data[i - 1]; // Use x(i)
            } 
            // Interpolation: x(i) + g * (x(i+1) - x(i))
            else {
                // Clamp i and i+1 indices to ensure we stay within data bounds
                
                // 1-based index i maps to 0-based index i-1.
                const idx_i = Math.max(0, Math.min(n - 1, i - 1));
                // 1-based index i+1 maps to 0-based index i.
                const idx_i_plus_1 = Math.max(0, Math.min(n - 1, i));

                const x_i = data[idx_i];
                const x_i_plus_1 = data[idx_i_plus_1];
                
                // Interpolate: x(i) + g * (x(i+1) - x(i))
                return x_i + g * (x_i_plus_1 - x_i);
            }
        }

        /**
         * Calculates IQR, Lower/Upper Bounds (1.5 * IQR rule), and identifies outliers.
         * @param {number[]} data - The full, sorted, cleaned dataset.
         * @param {number} Q1 - The first quartile (25%) calculated by a specific R type.
         * @param {number} Q3 - The third quartile (75%) calculated by a specific R type.
         * @returns {{IQR: number, LB: number, UB: number, outliers: number[]}}
         */
        function getIQRBoundsAndOutliers(data, Q1, Q3) {
            const IQR = Q3 - Q1;
            const k = 1.5 * IQR;
            const LB = Q1 - k;
            const UB = Q3 + k;

            const outliers = data.filter(val => val < LB || val > UB);

            return {
                IQR: IQR,
                LB: LB,
                UB: UB,
                outliers: outliers
            };
        }


        // --- Drag/Toggle Logic for Buttons ---
        
        function handleButtonInteraction(event) {
            const button = event.currentTarget; 
            if (!button || !button.classList.contains('type-btn')) return;

            const toggleButton = () => {
                const isActive = button.classList.contains('active');
                const activeButtons = document.querySelectorAll('.type-btn.active');
                
                // If trying to deactivate, ensure at least one button remains active
                if (isActive && activeButtons.length === 1) {
                    return; 
                }

                button.classList.toggle('active');
            };

            if (event.type === 'mousedown') {
                event.preventDefault(); 
                if (event.button === 0) {
                    isDragging = true;
                    toggleButton(); 
                }
            } 
            else if (event.type === 'mouseenter' && isDragging) {
                toggleButton(); 
            }
        }

        function setupDragInteraction() {
            const buttons = document.querySelectorAll('.type-btn');

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            buttons.forEach(button => {
                button.addEventListener('mousedown', handleButtonInteraction);
                button.addEventListener('mouseenter', handleButtonInteraction);
            });
        }
        
        /**
         * Toggles the outlier analysis feature ON/OFF.
         */
        window.toggleOutlierAnalysis = function() {
            const toggle = document.getElementById('show-outliers-toggle');
            const circle = document.getElementById('outlier-toggle-circle');

            showOutliers = !showOutliers;

            if (showOutliers) {
                toggle.classList.remove('bg-gray-300');
                toggle.classList.add('bg-blue-500');
                circle.classList.add('translate-x-6');
                toggle.setAttribute('aria-checked', 'true');
            } else {
                toggle.classList.remove('bg-blue-500');
                toggle.classList.add('bg-gray-300');
                circle.classList.remove('translate-x-6');
                circle.classList.remove('translate-x-full'); // Ensure it snaps back correctly if needed
                toggle.setAttribute('aria-checked', 'false');
            }
            
            // Re-run simulation to update results/R code if data exists, without flashing
            if (rawDataArray.length > 0) {
                // FIX for fast toggling: Debounce the runRCode call
                debounce(runRCode, 400)(true); 
            }
        }

        // --- Utility Functions ---

        /**
         * Formats a number for DISPLAY: 
         */
        function formatDisplayPrecision(num) {
            if (typeof num !== 'number' || isNaN(num)) {
                return 'NA';
            }
            // Use toPrecision(15) to maintain accuracy, then replace trailing zeros/decimal points
            return Number(num.toPrecision(15)).toString();
        }

        /**
         * Formats a number for COPYING: 
         */
        function formatCopyPrecision(num) {
            if (typeof num !== 'number' || isNaN(num)) {
                return 'NA';
            }
            // Use toFixed(15) to ensure exactly 15 decimal places for copy
            return num.toFixed(15); 
        }

        /**
         * Copies text to the clipboard and provides visual feedback via a toast notification.
         */
        function copyToClipboard(textToCopy, feedbackText = 'Copied to Clipboard!') {
            const tempTextArea = document.createElement('textarea');
            tempTextArea.style.position = 'fixed';
            tempTextArea.style.opacity = '0';
            tempTextArea.value = textToCopy; 
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            
            try {
                document.execCommand('copy'); 
                
                const toast = document.getElementById('copy-toast');
                toast.textContent = feedbackText;
                toast.classList.remove('opacity-0');
                toast.classList.add('opacity-100');

                setTimeout(() => {
                    toast.classList.remove('opacity-100');
                    toast.classList.add('opacity-0');
                }, 1500);

            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            document.body.removeChild(tempTextArea);
        }

        /**
         * Hides the copy buttons container smoothly (FADE OUT).
         */
        function hideCopyButtons() {
            const container = document.getElementById('copy-buttons-container');
            container.classList.add('copy-buttons-fade-leave-active');
            container.classList.remove('copy-buttons-fade-enter-active');
            // Remove the class after transition to reset to initial state
            setTimeout(() => {
                container.classList.remove('copy-buttons-fade-leave-active');
                container.classList.add('copy-buttons-fade-enter'); // Initial state is hidden
            }, 300); // Match transition duration
        }

        /**
         * Shows the copy buttons container smoothly (FADE IN).
         */
        function showCopyButtons() {
            const container = document.getElementById('copy-buttons-container');
            container.classList.remove('copy-buttons-fade-enter');
            container.classList.add('copy-buttons-fade-enter-active');
            container.classList.remove('copy-buttons-fade-leave-active');
        }


        // --- Clear Data Feature ---
        window.clearDataInput = function() {
            const containerElement = document.getElementById('results-container');
            
            // Animation Feedback: Flash border green
            containerElement.classList.add('flash-border-green');
            setTimeout(() => containerElement.classList.remove('flash-border-green'), 1000); 
            
            // Clear the data input field
            document.getElementById('data-input').value = '';
            
            // Clear results display 
            containerElement.innerHTML = '<p class="text-gray-500 text-center py-4">Results will appear here after running the simulation.</p>';
            
            // Reset the global result storage and hide copy buttons
            simulationResults = [];
            rawDataArray = [];
            initialDataInputCount = 0; // NEW: Reset count
            hideCopyButtons();

            // FIX: Clear pending timers when clearing data
            cardTimers.forEach(timer => clearTimeout(timer));
            cardTimers = [];

            copyToClipboard("", "Data and Results Cleared!");
        }

        // --- Copy R Compiler Link Feature ---
        window.copyRCompilerLink = function() {
            const linkToCopy = "https://www.programiz.com/r/online-compiler/";
            const btn = document.getElementById('copy-r-compiler-link');
            const originalText = btn.textContent;
            
            // Use the existing global copy function
            copyToClipboard(linkToCopy, 'R Compiler Link Copied!');
        
            // Visual feedback
            btn.textContent = 'Link Copied!';
            btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
            btn.classList.remove('bg-blue-600', 'hover:bg-blue-700'); 
            
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700'); 
            }, 1000); 
        }

        // --- Copy R Documentation Link Feature ---
        window.copyRDocumentationLink = function() {
            // The URL to copy is the link itself, not the citation text.
            const urlToCopy = "https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/quantile"; // Changed variable name and content
            
            // Find the element to give visual feedback (assuming the <p> tag has a class/id for styling)
            const feedbackElement = document.querySelector('.citation-copyable'); 
            
            // Use the existing global copy function
            copyToClipboard(urlToCopy, 'URL Copied to Clipboard!'); // Updated variable and feedback text
            
            // Optional: Add a brief visual flash for feedback
            if (feedbackElement) {
                const originalStyle = feedbackElement.style.border;
                feedbackElement.style.border = '2px solid #3b82f6'; // Blue border flash
                setTimeout(() => {
                    feedbackElement.style.border = originalStyle;
                }, 300);
            }
        }


        // --- R Code Copy Feature ---

        window.copyRCode = function() {
            if (rawDataArray.length === 0) {
                copyToClipboard("", "Error: No data available to generate R code.");
                return;
            }

            const dataString = rawDataArray.join(', ');
            const probabilities = "c(0, 0.25, 0.50, 0.75, 1)";
            
            let rCode = `
# R Code to Verify Quantile Calculations
# Paste this entire block into R or RStudio

data_vector <- c(${dataString})
probabilities <- ${probabilities}

# -------------------------------------------------------------
# 1. QUANTILE CALCULATIONS (Types 1-9)
# -------------------------------------------------------------
# Initialize an empty list to store quantile results
results_list <- list()

# Loop through all 9 types to calculate quantiles
for (type in 1:9) {
  # Calculate quantiles using the selected type
  quantiles <- quantile(data_vector, probs = probabilities, type = type)
  # Store results
  results_list[[paste0("Type ", type)]] <- quantiles
}

# Combine quantile results into a data frame
quantile_results_df <- as.data.frame(results_list)

# Print Quantile Results (Rows are Types, Columns are Probs)
cat("--- Quantile Results (Rows are Types, Columns are Probs) ---\\n")
print(t(quantile_results_df))
    `.trim();

            // Conditional Outlier Code
            if (showOutliers) {
                const outlierCode = `
# -------------------------------------------------------------
# 2. OUTLIER ANALYSIS (1.5 * IQR Rule) for Each Quantile Type
# -------------------------------------------------------------
outlier_results <- list()

for (type in 1:9) {
  # 1. Calculate Q1 (25%) and Q3 (75%) for the specific type
  # Note: The IQR and bounds change depending on the 'type' used to calculate Q1 and Q3
  qnt <- quantile(data_vector, probs = c(0.25, 0.75), type = type)
  
  # 2. Calculate IQR and Bounds
  IQR <- qnt[2] - qnt[1]
  lower_bound <- qnt[1] - 1.5 * IQR
  upper_bound <- qnt[2] + 1.5 * IQR
  
  # 3. Identify Outliers
  outliers <- data_vector[data_vector < lower_bound | data_vector > upper_bound]
  
  # 4. Store results
  outlier_results[[paste0("Type ", type)]] <- list(
    Q1 = qnt[1],
    Q3 = qnt[2],
    IQR = IQR,
    LowerBound = lower_bound,
    UpperBound = upper_bound,
    Outliers = if(length(outliers) > 0) paste(outliers, collapse = ", ") else "None"
  )
}

# Print Outlier Results (Use a loop to print formatted text)
cat("\\n--- Outlier Bounds & Identified Outliers for Each Quantile Type ---\\n")
for (name in names(outlier_results)) {
    res <- outlier_results[[name]]
    cat(paste0(name, ":\\n"))
    # Using round(., 4) for cleaner console output
    cat(paste0("  Q1: ", round(res$Q1, 4), ", Q3: ", round(res$Q3, 4), "\\n"))
    cat(paste0("  IQR: ", round(res$IQR, 4), ", LB: ", round(res$LowerBound, 4), ", UB: ", round(res$UpperBound, 4), "\\n"))
    cat(paste0("  Outliers: ", res$Outliers, "\\n"))
    cat("----------------------------------\\n")
}
        `.trim();
        rCode += `\n\n${outlierCode}`;
    }

            
            const btn = document.getElementById('copy-r-code-button');
            const originalText = btn.textContent;
            
            copyToClipboard(rCode, 'R Verification Code Copied!');

            btn.textContent = 'Copied!';
            btn.classList.add('bg-purple-500', 'hover:bg-purple-600');
            btn.classList.remove('bg-purple-600', 'hover:bg-purple-700'); // Note: changed from original bg-purple-700
            
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('bg-purple-500', 'hover:bg-purple-600');
                btn.classList.add('bg-purple-600', 'hover:bg-purple-700'); 
            }, 1000); 
        }

        // --- Copy All and Copy Single Functions ---

        window.copyAllResults = function() {
            if (simulationResults.length === 0) return;

            let header = "Type\tP0%\tP25%\tP50%\tP75%\tP100%";
            if (showOutliers) {
                header += "\tIQR\tLowerBound\tUpperBound\tOutliers";
            }
            
            const dataRows = simulationResults.map(result => {
                let row = result.values.map(formatCopyPrecision).join('\t'); 
                
                if (result.outlier) {
                    const o = result.outlier;
                    const outlierList = o.outliers.length > 0 ? `"${o.outliers.map(formatCopyPrecision).join(', ')}"` : 'None';
                    row += `\t${formatCopyPrecision(o.IQR)}\t${formatCopyPrecision(o.LB)}\t${formatCopyPrecision(o.UB)}\t${outlierList}`;
                }
                
                return `Type ${result.type}\t${row}`;
            }).join('\n');
            
            const textToCopy = `${header}\n${dataRows}`;
            
            const btn = document.getElementById('copy-all-button');
            const originalText = btn.textContent;
            
            copyToClipboard(textToCopy, 'All Results Copied!');

            btn.textContent = 'Copied!';
            btn.classList.add('bg-green-500', 'hover:bg-green-600');
            btn.classList.remove('bg-green-600', 'hover:bg-green-700'); 
            
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('bg-green-500', 'hover:bg-green-600');
                btn.classList.add('bg-green-600', 'hover:bg-green-700'); 
            }, 1000); 
        }


        window.copySingleResult = function(type) {
            const result = simulationResults.find(r => r.type === type);
            if (!result) return;

            let header = "Type\tP0%\tP25%\tP50%\tP75%\tP100%";
            let row = result.values.map(formatCopyPrecision).join('\t'); 

            if (result.outlier) {
                header += "\tIQR\tLowerBound\tUpperBound\tOutliers";
                const o = result.outlier;
                const outlierList = o.outliers.length > 0 ? `"${o.outliers.map(formatCopyPrecision).join(', ')}"` : 'None';
                row += `\t${formatCopyPrecision(o.IQR)}\t${formatCopyPrecision(o.LB)}\t${formatCopyPrecision(o.UB)}\t${outlierList}`;
            }
            
            const dataRow = `Type ${result.type}\t${row}`;
            const textToCopy = `${header}\n${dataRow}`;

            copyToClipboard(textToCopy, `Type ${type} Row Copied!`);
        }


        /**
         * Creates a visual card for a single quantile result.
         */
        function createResultCard(type, values, outlierAnalysis) {
            const container = document.getElementById('results-container');
            const typeKey = `Type ${type}`;
            const probs_labels = ["0%", "25%", "50%", "75%", "100%"];
            
            // Format values for DISPLAY: use formatDisplayPrecision
            const display_values = values.map(formatDisplayPrecision);

            const card = document.createElement('div');
            // Check the screenshot for the border color of the card
            const cardBorderColor = type === 1 ? 'border-blue-500' : 'border-blue-500'; 
            card.className = `result-card bg-white p-3 rounded-lg shadow-md border-t-4 ${cardBorderColor} mb-3`; 
            card.setAttribute('onclick', `copySingleResult(${type})`);
            card.setAttribute('title', `Click anywhere here to copy Type ${type} results for Excel`);
            
            let cardHtml = `
                <div class="flex justify-between items-center mb-2 border-b pb-1">
                    <h3 class="text-base font-bold text-blue-800">${typeKey}</h3>
                </div>
                <div class="grid grid-cols-2 sm:grid-cols-5 gap-2">
                    ${probs_labels.map((label, index) => {
                        const displayValue = display_values[index];
                        return `
                            <div class="flex flex-col p-1 border border-gray-200 rounded bg-gray-50">
                                <p class="text-gray-500 font-semibold mb-0 text-xs">${label}</p>
                                <p class="font-mono-data text-gray-900 break-all text-xs pr-1 leading-tight">${displayValue}</p>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;

            // Outlier Analysis Section (UPDATED COLORS TO ORANGE/BROWN)
            let outlierHtml = '';
            if (outlierAnalysis) {
                const { IQR, LB, UB, outliers } = outlierAnalysis;
                
                // Format outlier values for display
                const formattedIQR = formatDisplayPrecision(IQR);
                const formattedLB = formatDisplayPrecision(LB);
                const formattedUB = formatDisplayPrecision(UB);
                
                const outlierList = outliers.length > 0 
                    ? outliers.map(o => formatDisplayPrecision(o)).join(', ') 
                    : 'None';

                outlierHtml = `
                    <div class="mt-3 pt-3 border-t border-gray-200">
                        <h4 class="text-sm font-bold text-orange-600 mb-2">Outlier Analysis (1.5 * IQR Rule)</h4>
                        <p class="text-xs text-gray-600 mb-2">Bounds calculated using Type ${type}'s Q1 and Q3.</p>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                            <div class="p-1 bg-orange-300 rounded font-semibold col-span-2 md:col-span-1">IQR: <span class="font-semibold">${formattedIQR}</span></div>
                            <div class="p-1 bg-orange-100 rounded font-semibold col-span-2 md:col-span-1">1.5 * IQR: <span class="font-semibold">${formatDisplayPrecision(1.5 * IQR)}</span></div>
                            <div class="p-1 bg-orange-300 rounded font-semibold col-span-2 md:col-span-1">Lower Bound: <span class="font-semibold">${formattedLB}</span></div>
                            <div class="p-1 bg-orange-300 rounded font-semibold col-span-2 md:col-span-1">Upper Bound: <span class="font-semibold">${formattedUB}</span></div>
                        </div>
                        <p class="text-xs mt-2 text-gray-800">
                            <span class="font-bold text-orange-600">Outliers:</span> 
                            <span class="semibold">${outlierList}</span>
                        </p>
                    </div>
                `;
            }

            card.innerHTML = cardHtml + outlierHtml;

            container.appendChild(card);
        }


        // --- Main Execution ---

        /**
         * Runs the simulation, calculates quantiles and optionally outliers.
         * @param {boolean} isRerunning - True if called from the toggle, skips flash animation.
         */
        function runRCode(isRerunning = false) {
            const containerElement = document.getElementById('results-container');
            const runButton = document.getElementById('run-button');
            
            runButton.disabled = true; // Disable immediately
            
            // FIX: Clear any pending card creation timers from previous runs
            cardTimers.forEach(timer => clearTimeout(timer));
            cardTimers = []; // Reset the array
            
            // 1. Trigger Animation Feedback ONLY HERE (Single Flash)
            if (!isRerunning) {
                containerElement.classList.add('flash-border-green');
                setTimeout(() => containerElement.classList.remove('flash-border-green'), 1000); 
            }

            // Reset results storage
            simulationResults = [];
            
            // Get data input
            const dataInput = document.getElementById('data-input').value.trim();
            // NEW: Count total number of inputs
            const rawInputArray = dataInput.replace(/[\s,]+/g, ',').split(',').filter(n => n.length > 0);
            initialDataInputCount = rawInputArray.length;

            // 2. Collect selected types
            const activeButtons = document.querySelectorAll('.type-btn.active');
            const uniqueSortedTypes = Array.from(activeButtons)
                .map(button => parseInt(button.dataset.type, 10))
                .filter(t => !isNaN(t))
                .sort((a, b) => a - b);

            // 3. Parse Data Input
            const cleanedInput = dataInput.replace(/[\s,]+/g, ','); 
            let dataArray = cleanedInput
                .split(',')
                .filter(n => n.length > 0) 
                .map(n => parseFloat(n)) 
                .filter(n => isFinite(n)); 
            
            dataArray.sort((a, b) => a - b); 
            rawDataArray = dataArray; // Store sorted data globally
            
            const processedDataCount = dataArray.length; // NEW: Number of valid data points

            // 4. Input Validation
            if (uniqueSortedTypes.length === 0) {
                containerElement.innerHTML = '<p class="text-red-600 text-center py-4 font-semibold">Error: Please select at least one Quantile Type (1-9).</p>';
                hideCopyButtons();
                runButton.disabled = false;
                return;
            }
            if (dataArray.length === 0) {
                containerElement.innerHTML = '<p class="text-red-600 text-center py-4 font-semibold">Error: Please enter valid comma- or space-separated numbers for data.</p>';
                hideCopyButtons();
                runButton.disabled = false;
                return;
            }

            const dataMin = dataArray[0];
            const dataMax = dataArray[dataArray.length - 1];

            // 5. Setup and Clear
            hideCopyButtons(); // Hide while running calculations
            
            // FIX: Clear the container *completely* before adding new content
            containerElement.innerHTML = '';
            
            // UPDATED: Display both input count and processed count
            containerElement.innerHTML = `
                <p class="text-sm text-gray-700 mb-4">
                    Total Inputs: ${initialDataInputCount}. 
                    Data Points Processed: ${processedDataCount}. 
                    Data Min: ${formatDisplayPrecision(dataMin)}, Max: ${formatDisplayPrecision(dataMax)}.
                </p>
            `;

            // Probabilities to calculate (0%, 25%, 50%, 75%, 100%)
            const probs = [0.0, 0.25, 0.5, 0.75, 1.0];

            // 6. Run Dynamic Calculation and Display Cards
            let delay = 0; 
            const stepDelay = 75; 
            const totalTypes = uniqueSortedTypes.length;

            uniqueSortedTypes.forEach((type, index) => {
                const values = probs.map(p => calculateQuantile(dataArray, p, type));

                let outlierAnalysis = null;
                if (showOutliers) {
                    // Q1 is index 1, Q3 is index 3 (from probs array [0, 0.25, 0.5, 0.75, 1.0])
                    const Q1 = values[1];
                    const Q3 = values[3];
                    outlierAnalysis = getIQRBoundsAndOutliers(dataArray, Q1, Q3);
                }

                simulationResults.push({ type: type, values: values, outlier: outlierAnalysis });

                // Store the timer ID for later cancellation
                const timerId = setTimeout(() => {
                    createResultCard(type, values, outlierAnalysis);
                    
                    if (index === totalTypes - 1) {
                        runButton.disabled = false;
                        showCopyButtons(); // Show buttons only after all are calculated
                    }
                }, delay);

                cardTimers.push(timerId); // NEW: Add timer to the global list

                delay += stepDelay;
            });
        }

        // Initialize button listeners and KaTeX rendering once DOM is ready
        window.onload = function() {
            setupDragInteraction();

            // Run KaTeX auto-render on the dedicated formula list container and main content
            if (typeof renderMathInElement !== 'undefined') {
                const bodyContent = document.querySelector('.max-w-5xl'); 
                
                if (bodyContent) {
                    renderMathInElement(bodyContent, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ]
                    });
                }
            }
        };

    </script>

</body>
</html>